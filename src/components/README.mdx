---
name: 介绍
path: /Intro
order: 99
---

## 项目介绍

本项目为公司内部高级组件库，所谓高级，是说项目内组件可能大部分都来自于已有组件，如 antd 的封装。封装组件的路径在下面有简单介绍。

组件预览框架基于 [`docz`](https://github.com/pedronauck/docz)，[`mdx`](https://github.com/mdx-js/mdx)。

有一些注意的小地方：

- 组件 demo 代码内部经常会见到 `onXxx = this.onXxx.bind(this)`，原因如上，实际项目使用 `arrow-function` 替代

## 设计规范

基于 `React@16.6` 进行组件开发，单个组件内部可能分成 `control`（受控） 和 `stational`（非受控，自有状态） 部分。

简单设计一个完全 control 组件，似乎很容易也不太容易出错，但是仍然需要注意一些点

- 暴露出来的回调方法，其参数不应该注入已经受控的状态参数
- 回调方法名称以 `onXxx` 驼峰格式命名

接下来，在 control 组件基础上，对一些常见内部状态和其常见操作逻辑进行封装，所有此类组件都是继承自 `StationalComponent`，这个类对一般逻辑进行了抽象，减少冗余代码。

详细介绍，建议阅读 [关于受控组件，你还可以多做一步](https://zhuanlan.zhihu.com/p/55845929)

### react hooks

组件状态复用，react 诞生以来，就不断改进，从一开始的 `mixins` 到 `extends` 再到 `React@16.7` 的 `hooks` 概念。

先插一句嘴，我认为 `hooks` 的诞生是被 `FuntionalComponent` 催生来的，其他技术的演变原因这里不讨论。

目前的设计和未来的 hooks 是否冲突

    从概念上是不冲突的，我们天然都是将状态管理和UI展示进行分离的，但是 hooks 在状态复用方面可以做到一组状态管理逻辑可以和任何一个组件进行结合使用，而基于 `class` 的组件设计，只有继承关系上组件才可以享受到这点了。使用角度上看，完全不受影响。

## 组件封装路径

组件都是从业务而来，如果多处地方出现了同样一段代码，考虑将它封装成组件（or utils，constants，services）。

第一步，抽离代码

    不用考虑接口设计，运行效率，甚至业务和UI无需分离，将重复的代码最大程度的提取出来，放到 `containers` 文件夹下，将抽离的位置都改为对应路径的引用。

第二步，封装组件

    封装组件的目标是，将业务和UI分离，考虑业务太过复杂，分离可以帮助代码整洁，或者是UI部分独立出来，供其他场景使用。

组件封装的步骤为

- 分离业务代码
- 分离 受控非受控 状态，参考 `设计规范` 内容
- 样式，测试，ts 类型参考已有组件，暂无详细介绍
